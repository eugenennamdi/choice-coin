{"ast":null,"code":"var _classCallCheck = require(\"C:/Users/EUGENE/ChoiceDev/Choice-Coin/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/EUGENE/ChoiceDev/Choice-Coin/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar Messenger = /*#__PURE__*/function () {\n  \"use strict\";\n\n  /**\n   * @callback onMessage\n   * @param {error} err\n   * @param {Object} result\n   */\n\n  /**\n   * @description Callback function to send response to the window source of the message\n   * @callback sendResponse\n   * @param {Object} response Message response\n   * @returns {void}\n   */\n\n  /**\n   * @description Callback function to manage message received from the channel\n      * @callback onMessageCallback\n      * @param {Object} json\n   * @param {Window} source\n      * @param {sendResponse} cb\n   * @param {Messenger} bridge\n   * @returns {void}\n      */\n\n  /**\n   * @description Send message options\n   * @typedef {Object} sendMessageOptions\n   * @property {boolean} waitForReply Wait for a reply from the recipient\n   * @property {string} origin Override Window.origin\n   * @property {number} timeout Timeout to wait for reply message, default 4000 msec\n   */\n\n  /**\n      * @param {string} channelName  Channel Name\n      * @param {onMessageCallback} [onMessageCallback] Callback function\n      */\n  function Messenger(channelName, onMessageCallback) {\n    _classCallCheck(this, Messenger);\n\n    this.channelName = channelName;\n    this.onMessage = onMessageCallback;\n\n    this._installListener();\n    /**\n     * @access private\n     * @typedef {Object.<string, onMessage>} RequestObject Request objects\n     * @type {RequestObject} _requests Mapping of request ids to callbacks\n     */\n\n\n    this._requests = new Map();\n    /**\n     * @access private\n     * @type {number} Next request id\n     */\n\n    this._nextId = 0;\n    /**\n     * @access private\n     * @type {number} Time to wait for the message response\n     */\n\n    this._defaultTimeout = 4000;\n  }\n  /**\n   * @access private\n   */\n\n\n  _createClass(Messenger, [{\n    key: \"_installListener\",\n    value: function _installListener() {\n      var that = this;\n      /**\n       * @access private\n       * @param {Window} this\n       * @param {MessageEvent} event\n       */\n\n      this._listener = function (event) {\n        // Ignore invalid messages or those after the client has closed\n        if (!event.data || typeof event.data !== 'string') {\n          return;\n        }\n\n        var json;\n\n        try {\n          json = JSON.parse(event.data);\n\n          if (!json.channel || json.channel !== that.channelName) {\n            return;\n          }\n\n          if (typeof json.message !== 'object') {\n            return;\n          }\n        } catch (err) {\n          // Ignore malformed messages or not targetting us\n          return;\n        } // Add request callback\n\n\n        if (typeof json.replyId !== 'undefined') {\n          if (typeof json.replyId !== 'number' || json.replyId % 1 !== 0) {\n            return;\n          } // If we have a message waiting for a reply, process it, else ignore\n\n\n          var req = that._requests.get(json.replyId);\n\n          if (req) {\n            clearTimeout(req.timeout);\n\n            that._requests.delete(json.replyId);\n\n            req.resolve(json.message);\n          }\n        } else {\n          if (typeof json.id !== 'number' || json.id % 1 !== 0 || !that.onMessage) {\n            return;\n          } // We received a message\n\n\n          var channel = that.channelName;\n          var replyId = json.id;\n          var origin = event.origin;\n\n          var replyMessage = function replyMessage(message) {\n            var request = {\n              channel: channel,\n              replyId: replyId,\n              message: message\n            };\n            event.source.postMessage(JSON.stringify(request), origin);\n          };\n\n          that.onMessage(json.message, event.origin, event.source, replyMessage, that);\n        }\n      };\n\n      window.addEventListener(\"message\", this._listener);\n    }\n    /**\n     * @access public\n     * @description Send a message to another window\n     * @param {Window} targetWindow Target Window\n     * @param {Object} message Object Message\n     * @param {string} origin Target origin\n     * @param {sendMessageOptions} [options] Object Message\n     * @returns {Promise<any>} Returns\n     */\n\n  }, {\n    key: \"sendMessage\",\n    value: function sendMessage(targetWindow, message, origin, options) {\n      // Prepare message\n      var request = {\n        channel: this.channelName,\n        id: this.getNextId(),\n        message: message\n      };\n\n      if (options && options.waitForReply) {\n        var that = this;\n        return new Promise(function (resolve, reject) {\n          // Set a timeout if a response is not received\n          var timeout = setTimeout(function () {\n            var req = that._requests.get(request.id);\n\n            if (req) {\n              that._requests.delete(request.id);\n\n              reject(new Error('Timeout expired for the message response'));\n            }\n          }, options && options.timeout ? options.timeout : that._defaultTimeout);\n\n          that._requests.set(request.id, {\n            timeout: timeout,\n            resolve: resolve\n          });\n\n          targetWindow.postMessage(JSON.stringify(request), origin);\n        });\n      }\n\n      targetWindow.postMessage(JSON.stringify(request), origin);\n    }\n    /**\n     * @access public\n     * @description Close client connection\n     */\n\n  }, {\n    key: \"close\",\n    value: function close() {\n      window.removeEventListener('message', this._listener);\n      this._listener = null;\n      delete this._requests;\n    }\n    /**\n     * @access private\n     */\n\n  }, {\n    key: \"getNextId\",\n    value: function getNextId() {\n      this._nextId += 1;\n      return this._nextId;\n    }\n  }]);\n\n  return Messenger;\n}();\n\nmodule.exports = Messenger;","map":{"version":3,"sources":["C:/Users/EUGENE/ChoiceDev/Choice-Coin/node_modules/@randlabs/communication-bridge/lib/messenger.js"],"names":["Messenger","channelName","onMessageCallback","onMessage","_installListener","_requests","Map","_nextId","_defaultTimeout","that","_listener","event","data","json","JSON","parse","channel","message","err","replyId","req","get","clearTimeout","timeout","delete","resolve","id","origin","replyMessage","request","source","postMessage","stringify","window","addEventListener","targetWindow","options","getNextId","waitForReply","Promise","reject","setTimeout","Error","set","removeEventListener","module","exports"],"mappings":";;;;IAAMA,S;;;AAEL;AACD;AACA;AACA;AACA;;AAEC;AACD;AACA;AACA;AACA;AACA;;AAEC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEC;AACD;AACA;AACA;AACA;AACA;AACA;;AAEC;AACD;AACA;AACA;AAEC,qBAAYC,WAAZ,EAAyBC,iBAAzB,EAA4C;AAAA;;AAC3C,SAAKD,WAAL,GAAmBA,WAAnB;AACA,SAAKE,SAAL,GAAiBD,iBAAjB;;AAEA,SAAKE,gBAAL;AAEA;AACF;AACA;AACA;AACA;;;AACE,SAAKC,SAAL,GAAiB,IAAIC,GAAJ,EAAjB;AAEA;AACF;AACA;AACA;;AACE,SAAKC,OAAL,GAAe,CAAf;AAEA;AACF;AACA;AACA;;AACE,SAAKC,eAAL,GAAuB,IAAvB;AACA;AAED;AACD;AACA;;;;;WAEC,4BAAmB;AAClB,UAAMC,IAAI,GAAG,IAAb;AAEA;AACF;AACA;AACA;AACA;;AAEE,WAAKC,SAAL,GAAiB,UAAUC,KAAV,EAAiB;AACjC;AACA,YAAI,CAACA,KAAK,CAACC,IAAP,IAAe,OAAOD,KAAK,CAACC,IAAb,KAAsB,QAAzC,EAAmD;AAClD;AACA;;AAED,YAAIC,IAAJ;;AAEA,YAAI;AACHA,UAAAA,IAAI,GAAGC,IAAI,CAACC,KAAL,CAAWJ,KAAK,CAACC,IAAjB,CAAP;;AACA,cAAI,CAACC,IAAI,CAACG,OAAN,IAAiBH,IAAI,CAACG,OAAL,KAAiBP,IAAI,CAACR,WAA3C,EAAwD;AACvD;AACA;;AACD,cAAI,OAAOY,IAAI,CAACI,OAAZ,KAAwB,QAA5B,EAAsC;AACrC;AACA;AACD,SARD,CASA,OAAOC,GAAP,EAAY;AACV;AACD;AACA,SApBgC,CAsBjC;;;AACA,YAAI,OAAOL,IAAI,CAACM,OAAZ,KAAwB,WAA5B,EAAyC;AAExC,cAAI,OAAON,IAAI,CAACM,OAAZ,KAAwB,QAAxB,IAAqCN,IAAI,CAACM,OAAL,GAAe,CAAhB,KAAuB,CAA/D,EAAkE;AACjE;AACA,WAJuC,CAMxC;;;AACA,cAAMC,GAAG,GAAGX,IAAI,CAACJ,SAAL,CAAegB,GAAf,CAAmBR,IAAI,CAACM,OAAxB,CAAZ;;AACA,cAAIC,GAAJ,EAAS;AACRE,YAAAA,YAAY,CAACF,GAAG,CAACG,OAAL,CAAZ;;AAEAd,YAAAA,IAAI,CAACJ,SAAL,CAAemB,MAAf,CAAsBX,IAAI,CAACM,OAA3B;;AAEAC,YAAAA,GAAG,CAACK,OAAJ,CAAYZ,IAAI,CAACI,OAAjB;AACA;AACD,SAfD,MAgBK;AACJ,cAAI,OAAOJ,IAAI,CAACa,EAAZ,KAAmB,QAAnB,IAAgCb,IAAI,CAACa,EAAL,GAAU,CAAX,KAAkB,CAAjD,IAAsD,CAACjB,IAAI,CAACN,SAAhE,EAA2E;AAC1E;AACA,WAHG,CAKJ;;;AACA,cAAMa,OAAO,GAAGP,IAAI,CAACR,WAArB;AACA,cAAMkB,OAAO,GAAGN,IAAI,CAACa,EAArB;AACA,cAAMC,MAAM,GAAGhB,KAAK,CAACgB,MAArB;;AAEA,cAAMC,YAAY,GAAG,SAAfA,YAAe,CAAUX,OAAV,EAAmB;AACvC,gBAAMY,OAAO,GAAG;AACfb,cAAAA,OAAO,EAAPA,OADe;AAEfG,cAAAA,OAAO,EAAPA,OAFe;AAGfF,cAAAA,OAAO,EAAEA;AAHM,aAAhB;AAMAN,YAAAA,KAAK,CAACmB,MAAN,CAAaC,WAAb,CACCjB,IAAI,CAACkB,SAAL,CAAeH,OAAf,CADD,EAECF,MAFD;AAIA,WAXD;;AAaAlB,UAAAA,IAAI,CAACN,SAAL,CAAeU,IAAI,CAACI,OAApB,EAA6BN,KAAK,CAACgB,MAAnC,EAA2ChB,KAAK,CAACmB,MAAjD,EAAyDF,YAAzD,EAAuEnB,IAAvE;AACA;AACD,OAhED;;AAkEAwB,MAAAA,MAAM,CAACC,gBAAP,CAAwB,SAAxB,EAAmC,KAAKxB,SAAxC;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,qBAAYyB,YAAZ,EAA0BlB,OAA1B,EAAmCU,MAAnC,EAA2CS,OAA3C,EAAoD;AACnD;AACA,UAAMP,OAAO,GAAG;AACfb,QAAAA,OAAO,EAAE,KAAKf,WADC;AAEfyB,QAAAA,EAAE,EAAE,KAAKW,SAAL,EAFW;AAGfpB,QAAAA,OAAO,EAAEA;AAHM,OAAhB;;AAMA,UAAImB,OAAO,IAAIA,OAAO,CAACE,YAAvB,EAAqC;AACpC,YAAM7B,IAAI,GAAG,IAAb;AAEA,eAAO,IAAI8B,OAAJ,CAAY,UAAUd,OAAV,EAAmBe,MAAnB,EAA2B;AAC7C;AACA,cAAMjB,OAAO,GAAGkB,UAAU,CAAC,YAAW;AACrC,gBAAMrB,GAAG,GAAGX,IAAI,CAACJ,SAAL,CAAegB,GAAf,CAAmBQ,OAAO,CAACH,EAA3B,CAAZ;;AACA,gBAAIN,GAAJ,EAAS;AACRX,cAAAA,IAAI,CAACJ,SAAL,CAAemB,MAAf,CAAsBK,OAAO,CAACH,EAA9B;;AAEAc,cAAAA,MAAM,CAAC,IAAIE,KAAJ,CAAU,0CAAV,CAAD,CAAN;AACA;AACD,WAPyB,EAOvBN,OAAO,IAAIA,OAAO,CAACb,OAAnB,GAA6Ba,OAAO,CAACb,OAArC,GAA+Cd,IAAI,CAACD,eAP7B,CAA1B;;AASAC,UAAAA,IAAI,CAACJ,SAAL,CAAesC,GAAf,CAAmBd,OAAO,CAACH,EAA3B,EAA+B;AAC9BH,YAAAA,OAAO,EAAPA,OAD8B;AAE9BE,YAAAA,OAAO,EAAPA;AAF8B,WAA/B;;AAKAU,UAAAA,YAAY,CAACJ,WAAb,CACCjB,IAAI,CAACkB,SAAL,CAAeH,OAAf,CADD,EAECF,MAFD;AAIA,SApBM,CAAP;AAsBA;;AACDQ,MAAAA,YAAY,CAACJ,WAAb,CACCjB,IAAI,CAACkB,SAAL,CAAeH,OAAf,CADD,EAECF,MAFD;AAIA;AAED;AACD;AACA;AACA;;;;WAEC,iBAAQ;AACPM,MAAAA,MAAM,CAACW,mBAAP,CAA2B,SAA3B,EAAsC,KAAKlC,SAA3C;AACA,WAAKA,SAAL,GAAiB,IAAjB;AACA,aAAO,KAAKL,SAAZ;AACA;AAED;AACD;AACA;;;;WAEC,qBAAY;AACX,WAAKE,OAAL,IAAgB,CAAhB;AACA,aAAO,KAAKA,OAAZ;AACA;;;;;;AAGFsC,MAAM,CAACC,OAAP,GAAiB9C,SAAjB","sourcesContent":["class Messenger {\n\n\t/**\n\t * @callback onMessage\n\t * @param {error} err\n\t * @param {Object} result\n\t */\n\n\t/**\n\t * @description Callback function to send response to the window source of the message\n\t * @callback sendResponse\n\t * @param {Object} response Message response\n\t * @returns {void}\n\t */\n\n\t/**\n\t * @description Callback function to manage message received from the channel\n     * @callback onMessageCallback\n     * @param {Object} json\n\t * @param {Window} source\n     * @param {sendResponse} cb\n\t * @param {Messenger} bridge\n\t * @returns {void}\n     */\n\n\t/**\n\t * @description Send message options\n\t * @typedef {Object} sendMessageOptions\n\t * @property {boolean} waitForReply Wait for a reply from the recipient\n\t * @property {string} origin Override Window.origin\n\t * @property {number} timeout Timeout to wait for reply message, default 4000 msec\n\t */\n\n\t/**\n     * @param {string} channelName  Channel Name\n     * @param {onMessageCallback} [onMessageCallback] Callback function\n     */\n\n\tconstructor(channelName, onMessageCallback) {\n\t\tthis.channelName = channelName;\n\t\tthis.onMessage = onMessageCallback;\n\n\t\tthis._installListener();\n\n\t\t/**\n\t\t * @access private\n\t\t * @typedef {Object.<string, onMessage>} RequestObject Request objects\n\t\t * @type {RequestObject} _requests Mapping of request ids to callbacks\n\t\t */\n\t\tthis._requests = new Map();\n\n\t\t/**\n\t\t * @access private\n\t\t * @type {number} Next request id\n\t\t */\n\t\tthis._nextId = 0;\n\n\t\t/**\n\t\t * @access private\n\t\t * @type {number} Time to wait for the message response\n\t\t */\n\t\tthis._defaultTimeout = 4000;\n\t}\n\n\t/**\n\t * @access private\n\t */\n\n\t_installListener() {\n\t\tconst that = this;\n\n\t\t/**\n\t\t * @access private\n\t\t * @param {Window} this\n\t\t * @param {MessageEvent} event\n\t\t */\n\n\t\tthis._listener = function (event) {\n\t\t\t// Ignore invalid messages or those after the client has closed\n\t\t\tif (!event.data || typeof event.data !== 'string') {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlet json;\n\n\t\t\ttry {\n\t\t\t\tjson = JSON.parse(event.data);\n\t\t\t\tif (!json.channel || json.channel !== that.channelName) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (typeof json.message !== 'object') {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (err) {\n\t\t\t\t // Ignore malformed messages or not targetting us\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Add request callback\n\t\t\tif (typeof json.replyId !== 'undefined') {\n\n\t\t\t\tif (typeof json.replyId !== 'number' || (json.replyId % 1) !== 0) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// If we have a message waiting for a reply, process it, else ignore\n\t\t\t\tconst req = that._requests.get(json.replyId);\n\t\t\t\tif (req) {\n\t\t\t\t\tclearTimeout(req.timeout);\n\n\t\t\t\t\tthat._requests.delete(json.replyId);\n\n\t\t\t\t\treq.resolve(json.message);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (typeof json.id !== 'number' || (json.id % 1) !== 0 || !that.onMessage) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// We received a message\n\t\t\t\tconst channel = that.channelName;\n\t\t\t\tconst replyId = json.id;\n\t\t\t\tconst origin = event.origin;\n\n\t\t\t\tconst replyMessage = function (message) {\n\t\t\t\t\tconst request = {\n\t\t\t\t\t\tchannel,\n\t\t\t\t\t\treplyId,\n\t\t\t\t\t\tmessage: message,\n\t\t\t\t\t};\n\n\t\t\t\t\tevent.source.postMessage(\n\t\t\t\t\t\tJSON.stringify(request),\n\t\t\t\t\t\torigin\n\t\t\t\t\t);\n\t\t\t\t};\n\n\t\t\t\tthat.onMessage(json.message, event.origin, event.source, replyMessage, that);\n\t\t\t}\n\t\t};\n\n\t\twindow.addEventListener(\"message\", this._listener);\n\t}\n\n\t/**\n\t * @access public\n\t * @description Send a message to another window\n\t * @param {Window} targetWindow Target Window\n\t * @param {Object} message Object Message\n\t * @param {string} origin Target origin\n\t * @param {sendMessageOptions} [options] Object Message\n\t * @returns {Promise<any>} Returns\n\t */\n\tsendMessage(targetWindow, message, origin, options) {\n\t\t// Prepare message\n\t\tconst request = {\n\t\t\tchannel: this.channelName,\n\t\t\tid: this.getNextId(),\n\t\t\tmessage: message,\n\t\t};\n\n\t\tif (options && options.waitForReply) {\n\t\t\tconst that = this;\n\n\t\t\treturn new Promise(function (resolve, reject) {\n\t\t\t\t// Set a timeout if a response is not received\n\t\t\t\tconst timeout = setTimeout(function() {\n\t\t\t\t\tconst req = that._requests.get(request.id);\n\t\t\t\t\tif (req) {\n\t\t\t\t\t\tthat._requests.delete(request.id);\n\n\t\t\t\t\t\treject(new Error('Timeout expired for the message response'));\n\t\t\t\t\t}\n\t\t\t\t}, options && options.timeout ? options.timeout : that._defaultTimeout);\n\n\t\t\t\tthat._requests.set(request.id, {\n\t\t\t\t\ttimeout,\n\t\t\t\t\tresolve\n\t\t\t\t});\n\n\t\t\t\ttargetWindow.postMessage(\n\t\t\t\t\tJSON.stringify(request),\n\t\t\t\t\torigin\n\t\t\t\t);\n\t\t\t});\n\n\t\t}\n\t\ttargetWindow.postMessage(\n\t\t\tJSON.stringify(request),\n\t\t\torigin\n\t\t);\n\t}\n\n\t/**\n\t * @access public\n\t * @description Close client connection\n\t */\n\n\tclose() {\n\t\twindow.removeEventListener('message', this._listener);\n\t\tthis._listener = null;\n\t\tdelete this._requests;\n\t}\n\n\t/**\n\t * @access private\n\t */\n\n\tgetNextId() {\n\t\tthis._nextId += 1;\n\t\treturn this._nextId;\n\t}\n}\n\nmodule.exports = Messenger;\n"]},"metadata":{},"sourceType":"script"}